@page "/manager"
@using CliWrap;
@using Microsoft.AspNetCore.Authorization;
@using Microsoft.AspNetCore.Components.Authorization;
@using OBSWebsocketDotNet;
@using Renci.SshNet;
@using System.Diagnostics;
@using System.Net.NetworkInformation;
@using Vultr.Clients;
@using Vultr.Models;
@using Vultr.Enums;
@using Microsoft.Data.Sqlite;

@inject IConfiguration configuration;
@inject IJSRuntime JS

@*@attribute [Authorize] *@

@inject NavigationManager NavManager;

<AuthorizeView>
    <Authorized>
        <p>Hello, @context.User?.Identity?.Name!</p>
        <p>obs_connected=@obs_connected.ToString()</p>
        <p><button @onclick="OnBtnStart" disabled="@(SharedState.BCastState != SharedState.BroadcastState.stopped)" name="Start">Start</button></p>
        <p><button @onclick="OnPause" disabled="@(SharedState.BCastState != SharedState.BroadcastState.running )" name="Pause">Pause</button></p>
        <p><button @onclick="OnResume" disabled="@(SharedState.BCastState != SharedState.BroadcastState.paused )" name="Resume">Resume</button></p>
        <p><button @onclick="OnStop" disabled="@(SharedState.BCastState == SharedState.BroadcastState.stopped || SharedState.BCastState == SharedState.BroadcastState.stopping )" name="Stop">Stop</button></p>
        @if (!String.IsNullOrWhiteSpace(alert_msg))
        {
            <p>@alert_msg</p>
        }
        <video id="local_video" defaultMuted="true" />
        <video id="remote_video">
            <source src="http://66.42.70.209:8000/live.ts", type="video/mp4"/>
        </video>
    </Authorized>
    <NotAuthorized>
        @{
            NavManager.NavigateTo("/");
        }
    </NotAuthorized>
</AuthorizeView>



@code {
    private OBSWebsocket obs = new OBSWebsocket();
    TaskCompletionSource<bool>? tcs = null;

    private string adminPW = "";
    private string appDir = "";
    private string broadcastManagerDnsName = "";
    private string broadcastServerDnsName = "";
    private string obsKey = "";
    private string obsUrl = "";
    private string rtspServerDownloadUrl = "";
    private const string rtspAppName = "rtsp-simple-server";
    private const string rtspArchiveName = "rtsp-simple-server.tar.gz";
    private string rtspAppDir = "";
    private string rtspArchiveDir = "";
    private string sshPrivateFile = "";
    private string sshPublicFile = "";
    private string vultrKey = "";

    private bool obs_connected;
    private string alert_msg = "";

    protected override async Task OnInitializedAsync()
    {
        if (SharedState.BCastState is null)
            SharedState.BCastState = SharedState.BroadcastState.stopped;
        obs_connected = obs.IsConnected;
        obs.Connected += onObsConnect;

        appDir = Path.GetDirectoryName(Process.GetCurrentProcess().MainModule.FileName) ?? "";
        broadcastManagerDnsName = configuration["BroadcastManagerDnsName"] ?? "";
        broadcastServerDnsName = configuration["BroadcastServerDnsName"] ?? "";

        obsKey = configuration["ObsApiKey"] ?? "";
        obsUrl = configuration["ObsUrl"] ?? "ws://127.0.0.1:4455";
        rtspServerDownloadUrl = configuration["RtspServerDownloadUrl"] ?? "";
        rtspAppDir = configuration["RtspAppDir"] ?? "/opt/rtsp-simple-server";
        rtspArchiveDir = Directory.GetParent(rtspAppDir.TrimEnd(Path.DirectorySeparatorChar)).FullName;
        sshPrivateFile = configuration["SshPrivateKeyFile"] ?? "BroadcastManager_ssh_key";
        sshPublicFile = configuration["SshPublicKeyFile"] ?? "BroadcastManager_ssh_key.pub";
        vultrKey = configuration["VultrApiKey"] ?? "";

        if (!Path.IsPathRooted(sshPrivateFile))
            sshPrivateFile = Path.Combine(appDir, sshPrivateFile);

        if (!Path.IsPathRooted(sshPublicFile))
            sshPublicFile = Path.Combine(appDir, sshPublicFile);

        // update dns records so that the broadcast manager can be found
        var dnsSplit = SplitDnsName(broadcastManagerDnsName);
        string ipv4Address = GetLocalIPv4();

        var dns = new UpdateCloudflareDNS(configuration["CloudFlareTokenKey"] ?? "");
        await dns.UpdateDnsAsync(dnsSplit.ZoneName, dnsSplit.RecordName, ipv4Address, new CancellationToken());


        await Task.Delay(0);
    }



    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
        }
        await Task.Delay(0);
    }

    private void onObsConnect(object? sender, EventArgs e)
    {
        obs_connected = obs.IsConnected;
        tcs?.TrySetResult(true);
        Refresh();
    }

    private async Task OnBtnStart()
    {
        // don't even bother to lock if the app state is not stopped
        if (SharedState.BCastState is not null && SharedState.BCastState != SharedState.BroadcastState.stopped)
            return; // somebody else pressed the start button already. Don't need to repeat what they've started.

        lock (SharedState.LockObj)// don't want to hold a lock for the whole startup process - just make sure we are first, and then continue or exit.
        {
            if (SharedState.BCastState is not null && SharedState.BCastState != SharedState.BroadcastState.stopped)
                return; // somebody else pressed the start button already. Don't need to repeat what they've started.
            else
                SharedState.BCastState = SharedState.BroadcastState.starting;
        }

        // generate an ssh key pair if either doesn't exist
        if (!File.Exists(sshPrivateFile) || !File.Exists(sshPublicFile))
        {
            var sshResult = Cli.Wrap("$(/usr/bin/which ssh-keygen)")
            .WithArguments($"-q -N '' -t ed25519 -C '{sshPrivateFile}' -f {Path.Combine(appDir, sshPrivateFile)}  <<<y >/dev/null 2>&1")
            .WithWorkingDirectory(appDir);
        }

        //// if the rtsp-simple-server isn't running, see if the executable exists & start it
        //Process[] rtspP = Process.GetProcessesByName("rtsp-simple-server");
        //if (rtspP.Length == 0)
        //{
        //    bool rtspAppExists = File.Exists(Path.Combine(rtspAppDir, rtspAppName));
        //    bool rtspArchiveExists = File.Exists(Path.Combine(rtspArchiveDir, rtspArchiveName));

        //    if (!rtspAppExists && !rtspArchiveExists) // download the archive from source
        //    {
        //        Cli.Wrap("$(/usr/bin/which wget)")
        //           .WithArguments($"--waitretry=30 --random-wait -O {Path.Combine(rtspArchiveDir, rtspArchiveName)} {rtspServerDownloadUrl} ");
        //    }

        //    if (rtspArchiveExists && !rtspAppExists) // extract the app from the archive 
        //    {
        //        Cli.Wrap("$(/usr/bin/which tar)").WithArguments($"-xaf {Path.Combine(rtspArchiveDir, rtspArchiveName)}");
        //    }

        //    // start the rtsp-simple-server
        //    Cli.Wrap(Path.Combine(rtspAppDir, rtspAppName))
        //        .WithArguments(Path.Combine(rtspAppDir, rtspAppName + ".yml") + " &");
        //}

        //// if obs isn't found on the local server, install it.
        //// push basic obs config for live and pause scenes, recording out to rtsp-simple-server via ffmpeg multicast
        //Process[] obsP = Process.GetProcessesByName("rtsp-simple-server");
        //if (obsP.Length == 0)
        //{
        //    CliWrap.Builders.CredentialsBuilder cb = new CliWrap.Builders.CredentialsBuilder();
        //    cb.SetUserName("***REMOVED***");
        //    cb.SetPassword(adminPW);

        //    // if app doesn't exist...
        //    Cli.Wrap("$(/usr/bin/which sudo)")
        //        .WithArguments("add-apt-repository -y ppa:obsproject/obs-studio")
        //        .WithCredentials(cb.Build())
        //        ;

        //}

        // check to see if we already have a record of a remote broadcast server running
        // if we do - check to see if the VULTR API shows it is running
        // if it is, check to see if we can connect to it
        // destroy it if we can't connect
        // start a new one if it doesn't exist

        var viInfo = StartVultrVm();

        // save the id, ip address, and label of the new instance
        SaveRemoteVmInfo(viInfo);

        // update DNS records so that the remote server can be found
        var dnsSplit = SplitDnsName(broadcastServerDnsName);
        var dns = new UpdateCloudflareDNS(configuration["CloudFlareTokenKey"] ?? "");
        await dns.UpdateDnsAsync(dnsSplit.ZoneName, dnsSplit.RecordName, viInfo.PublicIPv4, new CancellationToken());


        // start ffmpeg stream to obs on local server
        // make sure obs is running on local server

        // connect to the obs websocket
        try
        {
            if (!obs.IsConnected)
                await obs.ConnectAsync(obsUrl, obsKey);
        }
        catch (Exception ex)
        {
            alert_msg = "Connection to OBS service failed : " + ex.Message;
        }


        tcs = new TaskCompletionSource<bool>();
        var obs_connect = tcs.Task;
        int timeout = 10 * 1000;
        if (!(await Task.WhenAny(obs_connect, Task.Delay(timeout)) == obs_connect))
        {
            // obs didn't start in time!
            alert_msg = "The OBS socket didn't connect in time!";
            return;
        }

        //    https://gist.github.com/steinwaywhw/a4cd19cda655b8249d908261a62687f8

        // make sure obs scene selected is camera? Or...
        obs.SetCurrentProgramScene("Camera");

        // make sure obs is streaming
        obs.StartRecord();

        // make sure rtsp-simple-server is running on local server

        // wait for remote server setup & 1st reboot to complete - poll & sleep
        
        // install ffmpeg
        // install docker (if needed)
        // setup rtmp broadcast service on remote server
        // setup user GUI on the remote server
        // configure services to start on boot on the remote server
        // start display of local stream on web page
        // start display of remote stream on web page

        Refresh();
        var result = JS.InvokeAsync<object>("PlayVideo", "local_video", "/videos/elephants.mp4", 0);

        SharedState.BCastState = SharedState.BroadcastState.running;

        //Refresh();
        await Task.Delay(0);
    }

    private async Task OnPause()
    {
        if (SharedState.BCastState == SharedState.BroadcastState.running)
        {
            // don't actuall pause the playback - just switch the video source to a static image
            var result = JS.InvokeAsync<string>("PauseVideo", "local_video");
            SharedState.BCastState = SharedState.BroadcastState.paused;
            await Task.Delay(0);
        }
        //Refresh();
        await Task.Delay(0);
    }

    private async Task OnResume()
    {
        if (SharedState.BCastState == SharedState.BroadcastState.paused)
        {
            var result = JS.InvokeAsync<object>("ResumeVideo", "local_video");
            SharedState.BCastState = SharedState.BroadcastState.running;
            // switch to sending static image & pre-recorded audio
        }
        Refresh();
        await Task.Delay(0);
    }

    private async Task OnStop()
    {
        // don't actually pause - shutdown source & stop & teardown icecast server
        SharedState.BCastState = SharedState.BroadcastState.stopped;
        var result = JS.InvokeAsync<string>("PauseVideo", "local_video");
        alert_msg = string.Empty;
        Refresh();
        await Task.Delay(0);
    }


    private void Refresh()
    {
        _ = InvokeAsync(() =>
        {
            StateHasChanged();
        });
    }


    private void SaveRemoteVmInfo(VultrInstanceInfo viInfo)
    {

        using (var connection = new SqliteConnection("Data Source=broadcast.db"))
        {
            connection.Open(); // will create the db file if it doesn't exist
            var command = connection.CreateCommand();

            command.CommandText = @"SELECT name 
FROM
  sqlite_schema
WHERE
  type ='table' 
  AND name = 'remote_vm'";

            if (command.ExecuteScalar() is null)
            {
                command.CommandText = "CREATE TABLE remote_vm (TEXT vm_id, TEXT vm_ip, TEXT vm_label);";
                command.ExecuteNonQuery();
            }

            command.CommandText =
                @"INSERT INTO remote_vm (vm_id, vm_ip, vm_label) SELECT $id, $ip, $label;";

            command.Parameters.AddWithValue("$id", viInfo.InstanceID);
            command.Parameters.AddWithValue("$ip", viInfo.PublicIPv4);
            command.Parameters.AddWithValue("$label", viInfo.InstanceLabel);
            command.ExecuteNonQuery();

            //using (var reader = command.ExecuteReader())
            //{
            //    while (reader.Read())
            //    {
            //        var name = reader.GetString(0);

            //        Console.WriteLine($"Hello, {name}!");
            //    }
            //}
        }
    }

    private void SetupRemoteBroadcastServer(string serverIP)
    {

        string rtspArchivePath = "/opt/rtsp-simple-server.tar.gz";
        string rtspConfPath = "/opt/rtsp-simple-server.yaml";

        PrivateKeyFile keyFile = new PrivateKeyFile("");
        Renci.SshNet.PrivateKeyAuthenticationMethod auth = new PrivateKeyAuthenticationMethod(username: "root", keyFiles: keyFile);
        ConnectionInfo ci = new ConnectionInfo(host: serverIP, username: "root", authenticationMethods: auth);
        using (ScpClient scpClient = new ScpClient(ci))
        using (StreamReader appReader = new StreamReader(""))
        using (StreamReader confReader = new StreamReader(""))
        {
            scpClient.Connect();
            scpClient.Upload(source: appReader.BaseStream, path: rtspArchivePath);
            scpClient.Upload(source: confReader.BaseStream, path: rtspConfPath);
            scpClient.Disconnect();
        }

        using (SshClient sshClient = new SshClient(ci))
        {
            sshClient.Connect();
            if (sshClient.IsConnected)
            {
                sshClient.RunCommand("apt install -y ffmpeg");
                sshClient.RunCommand($"tar -xaf {rtspArchivePath} ; mv {rtspConfPath} /opt/rtsp-simple-server ; ");
                sshClient.Disconnect();
            }
        }
    }

    private VultrInstanceInfo StartVultrVm()
    {

        string sshPublicKey = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIHdSv++W8xf2H2mUj4bXIpkZrr6mi5tTG7Qq6i4dgGin IF_North_BroadcastManager";

        Vultr.API.VultrClient vc = new Vultr.API.VultrClient(apiKey: "***REMOVED***", apiURL: "https://api.vultr.com/v2/");

        var sshList = vc.SSHKey.GetSSHKeys();
        var sshKey = sshList.SshKeys.Where(s => s.ssh_key == sshPublicKey).FirstOrDefault(new Ssh_Key());

        if (string.IsNullOrEmpty(sshKey.id))
            sshKey = vc.SSHKey.CreateSSHKey(name: "IF_North_BroadcastManager", ssh_key: sshPublicKey).SshKeys.FirstOrDefault();

        var regions = vc.Region.GetRegions();
        string[] excludedRegions = new[] { "atl", "ewr", "hnl", "mia", "ord", "lax" };
        var usRegions = regions.Regions.Where(r => r.country == "US" && !excludedRegions.Any(e => r.id.Contains(e))).ToList();

        var plans = vc.Plan.GetPlans(Vultr.Enums.PlanTypes.all);
        var sizedPlans = plans.Plans.Where(p => p.vcpu_count >= 2 && p.ram >= 4000 && p.type == PlanTypes.vhf.ToString()).ToList();

        var r2 = sizedPlans.FindAll(p => usRegions.Any(r => p.locations.Contains(r.id))).OrderBy(p => p.monthly_cost).ToArray();
        var plan1 = r2.FirstOrDefault(new Plan());
        var regionID = plan1.locations.Where(p => usRegions.Any(r => p.Contains(r.id))).FirstOrDefault("");

        var os_result = vc.OperatingSystem.GetOperatingSystems();
        var os = os_result.osList.Where(o => o.family == "ubuntu" && o.arch == "x64" && o.name.Contains("LTS")).ToList().OrderBy(o => o.name).ToList().LastOrDefault(new Os());

        var script = vc.StartupScript.GetStartupScripts().StartupScripts.Where(s => s.name == "test").FirstOrDefault(new Startup_Scripts());

        var sshkey = vc.SSHKey.GetSSHKeys();

        var instanceInfo = vc.Instance.CreateInstance(Label: "Broadcaster", Hostname: "broadcaster", RegionID: regionID, PlanID: plan1.id, SourceID: os.id.ToString(), Source: Vultr.Clients.InstanceClient.SourceType.os, ScriptID: script.id, SshKeyIDs: new[] { sshKey.id });

        VultrInstanceInfo viInfo = new VultrInstanceInfo() { InstanceID = instanceInfo.Instances[0].id };

        var instanceDetail = vc.Instance.GetInstance(viInfo.InstanceID);
        viInfo.PublicIPv4 = instanceDetail.Instances[0].main_ip;
        viInfo.InstanceLabel = instanceDetail.Instances[0].label;

        //var instanceList = vc.Instance.ListInstances();
        //var bcastInstance = instanceList.Instances.Where(o => o.label == "Broadcaster").FirstOrDefault(new Instance());

        //var instanceDelResult = vc.Instance.DeleteInstance(bcastInstance.id);
        return viInfo;
    }

    private struct VultrInstanceInfo
    {
        public string InstanceID { get; set; }
        public string PublicIPv4 { get; set; }
        public string InstanceLabel { get; set; }
    }

    private struct DnsSplit
    {
        public string RecordName { get; set; }
        public string ZoneName { get; set; }
    }

    private DnsSplit SplitDnsName(string dnsName)
    {
        var regex = new System.Text.RegularExpressions.Regex(@"(?<record>.*)\.(?<zone>[^.]*\..*$)");
        var match = regex.Match(broadcastManagerDnsName);
        var recordName = match.Groups["record"].Value;
        var zoneName = match.Groups["zone"].Value;
        DnsSplit split = new DnsSplit { RecordName = recordName, ZoneName = zoneName };
        return split;
    }

    internal static string GetLocalIPv4(NetworkInterfaceType _type = NetworkInterfaceType.Unknown)
    {  // Checks your IP adress from the local network connected to a gateway. This to avoid issues with double network cards
        string output = "";  // default output
        foreach (NetworkInterface item in NetworkInterface.GetAllNetworkInterfaces()) // Iterate over each network interface
        {  // Find the network interface which has been provided in the arguments, break the loop if found
            if ((_type != NetworkInterfaceType.Unknown || item.NetworkInterfaceType == _type ) && item.OperationalStatus == OperationalStatus.Up)
            {   // Fetch the properties of this adapter
                IPInterfaceProperties adapterProperties = item.GetIPProperties();
                // Check if the gateway adress exist, if not its most likley a virtual network or smth
                if (adapterProperties.GatewayAddresses.FirstOrDefault() != null)
                {   // Iterate over each available unicast adresses
                    foreach (UnicastIPAddressInformation ip in adapterProperties.UnicastAddresses)
                    {   // If the IP is a local IPv4 adress
                        if (ip.Address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)
                        {   // we got a match!
                            output = ip.Address.ToString();
                            break;  // break the loop!!
                        }
                    }
                }
            }
            // Check if we got a result if so break this method
            if (output != "") { break; }
        }
        // Return results
        return output;
    }



}

