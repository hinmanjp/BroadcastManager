@page "/manager"
@using CliWrap;
@using Microsoft.AspNetCore.Authorization;
@using Microsoft.AspNetCore.Components.Authorization;
@using OBSWebsocketDotNet;
@using Renci.SshNet;
@using System.Diagnostics;
@using System.Net.NetworkInformation;
@using System.ComponentModel;
@using Vultr.Clients;
@using Vultr.Models;
@using Vultr.Enums;
@using Microsoft.Data.Sqlite;

@inject IConfiguration configuration;
@inject IJSRuntime JS

@*@attribute [Authorize] *@

@inject NavigationManager NavManager;

<AuthorizeView>
    <Authorized>
        <p>Hello, @context.User?.Identity?.Name!</p>
        <p>obs_connected=@obs_connected.ToString()</p>
        <p><button @onclick="OnBtnStart" disabled="@(SharedState.BCastState != SharedState.BroadcastState.stopped)" name="Start">Start</button></p>
        <p><button @onclick="OnPause" disabled="@(SharedState.BCastState != SharedState.BroadcastState.running )" name="Pause">Pause</button></p>
        <p><button @onclick="OnResume" disabled="@(SharedState.BCastState != SharedState.BroadcastState.paused )" name="Resume">Resume</button></p>
        <p><button @onclick="OnStop" disabled="@(SharedState.BCastState == SharedState.BroadcastState.stopped || SharedState.BCastState == SharedState.BroadcastState.stopping )" name="Stop">Stop</button></p>
        @if (!String.IsNullOrWhiteSpace(alert_msg))
        {
            <p>@alert_msg</p>
        }



@* <iframe width="560" height="315" src="https://test.willowbrook-ward.org:8888/sac1" frameborder="0" allowfullscreen></iframe> *@
      

@*        <video id="local_video" defaultMuted="true" />
        <video id="remote_video">
            <source src="http://66.42.70.209:8000/live.ts", type="video/mp4"/>
        </video>*@
    </Authorized>
    <NotAuthorized>
        @{
            NavManager.NavigateTo("/");
        }
    </NotAuthorized>
</AuthorizeView>



@code {
    private OBSWebsocket obs = new OBSWebsocket();
    private TaskCompletionSource<bool>? tcs = null;

    private string adminPW = "";
    private string appDir = "";
    private string broadcastManagerDnsName = "";
    private string broadcastServerDnsName = "";
    private string obsKey = "";
    private string obsUrl = "";
    private string rtspServerDownloadUrl = "";
    private const string rtspAppName = "rtsp-simple-server";
    private const string rtspArchiveName = "rtsp-simple-server.tar.gz";
    private string rtspArchiveFullPath = "";
    private string rtspAppDir = "";
    private string rtspArchiveDir = "";
    private string sshPrivateFile = "";
    private string sshPublicFile = "";
    private string vultrKey = "";
    private string vultrUrl = "https://api.vultr.com/v2/";
    private int waitForObsConnection;

    private bool obs_connected;
    private string alert_msg = "";

    protected override async Task OnInitializedAsync()
    {
        if (SharedState.BCastState is null)
            SharedState.BCastState = SharedState.BroadcastState.stopped;
        obs_connected = obs.IsConnected;
        obs.Connected += onObsConnect;

        appDir = Path.GetDirectoryName(Process.GetCurrentProcess().MainModule.FileName) ?? "";
        broadcastManagerDnsName = configuration["BroadcastManagerDnsName"] ?? "";
        broadcastServerDnsName = configuration["BroadcastServerDnsName"] ?? "";

        obsKey = configuration["ObsApiKey"] ?? "";
        obsUrl = configuration["ObsUrl"] ?? "ws://127.0.0.1:4455";
        rtspServerDownloadUrl = configuration["RtspServerDownloadUrl"] ?? "";
        rtspAppDir = configuration["RtspAppDir"] ?? "/opt/rtsp-simple-server";
        rtspArchiveDir = Directory.GetParent(rtspAppDir.TrimEnd(Path.DirectorySeparatorChar)).FullName;
        sshPrivateFile = configuration["SshPrivateKeyFile"] ?? "BroadcastManager_ssh_key";
        sshPublicFile = configuration["SshPublicKeyFile"] ?? "BroadcastManager_ssh_key.pub";
        vultrKey = configuration["VultrApiKey"] ?? "";
        waitForObsConnection = Convert.ToInt32(configuration["WaitSecsForObsConnection"] ?? "10");

        if (!Path.IsPathRooted(sshPrivateFile))
            sshPrivateFile = Path.Combine(appDir, sshPrivateFile);

        if (!Path.IsPathRooted(sshPublicFile))
            sshPublicFile = Path.Combine(appDir, sshPublicFile);

        if (!Path.IsPathRooted(rtspArchiveName))
            rtspArchiveFullPath = Path.Combine(appDir, rtspArchiveName);

        await Task.Delay(0);
    }



    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
        }
        await Task.Delay(0);
    }

    private void onObsConnect(object? sender, EventArgs e)
    {
        obs_connected = obs.IsConnected;
        tcs?.TrySetResult(true);
        Refresh();
    }

    private async Task OnBtnStart()
    {
        // don't even bother to lock if the app state is not stopped
        if (SharedState.BCastState is not null && SharedState.BCastState != SharedState.BroadcastState.stopped)
            return; // somebody else pressed the start button already. Don't need to repeat what they've started.

        lock (SharedState.LockObj)// don't want to hold a lock for the whole startup process - just make sure we are first, and then continue or exit.
        {
            if (SharedState.BCastState is not null && SharedState.BCastState != SharedState.BroadcastState.stopped)
                return; // somebody else pressed the start button already. Don't need to repeat what they've started.
            else
                SharedState.BCastState = SharedState.BroadcastState.starting;
        }

        // generate an ssh key pair if either doesn't exist
        if (!File.Exists(sshPrivateFile) || !File.Exists(sshPublicFile))
        {
            var sshResult = Cli.Wrap("$(/usr/bin/which ssh-keygen)")
            .WithArguments($"-q -N '' -t ed25519 -C '{sshPrivateFile}' -f {Path.Combine(appDir, sshPrivateFile)}  <<<y >/dev/null 2>&1")
            .WithWorkingDirectory(appDir);
        }

        //// if the rtsp-simple-server isn't running, see if the executable exists & start it
        //Process[] rtspP = Process.GetProcessesByName("rtsp-simple-server");
        //if (rtspP.Length == 0)
        //{
        //    bool rtspAppExists = File.Exists(Path.Combine(rtspAppDir, rtspAppName));
        //    bool rtspArchiveExists = File.Exists(Path.Combine(rtspArchiveDir, rtspArchiveName));

        //    if (!rtspAppExists && !rtspArchiveExists) // download the archive from source
        //    {
        //        Cli.Wrap("$(/usr/bin/which wget)")
        //           .WithArguments($"--waitretry=30 --random-wait -O {Path.Combine(rtspArchiveDir, rtspArchiveName)} {rtspServerDownloadUrl} ");
        //    }

        //    if (rtspArchiveExists && !rtspAppExists) // extract the app from the archive 
        //    {
        //        Cli.Wrap("$(/usr/bin/which tar)").WithArguments($"-xaf {Path.Combine(rtspArchiveDir, rtspArchiveName)}");
        //    }

        //    // start the rtsp-simple-server
        //    Cli.Wrap(Path.Combine(rtspAppDir, rtspAppName))
        //        .WithArguments(Path.Combine(rtspAppDir, rtspAppName + ".yml") + " &");
        //}

        //// if obs isn't found on the local server, install it.
        //// push basic obs config for live and pause scenes, recording out to rtsp-simple-server via ffmpeg multicast
        //Process[] obsP = Process.GetProcessesByName("rtsp-simple-server");
        //if (obsP.Length == 0)
        //{
        //    CliWrap.Builders.CredentialsBuilder cb = new CliWrap.Builders.CredentialsBuilder();
        //    cb.SetUserName("***REMOVED***");
        //    cb.SetPassword(adminPW);

        //    // if app doesn't exist...
        //    Cli.Wrap("$(/usr/bin/which sudo)")
        //        .WithArguments("add-apt-repository -y ppa:obsproject/obs-studio")
        //        .WithCredentials(cb.Build())
        //        ;

        //}

        // check to see if we already have a record of a remote broadcast server running
        // if we do - check to see if the VULTR API shows it is running
        // if it is, check to see if we can connect to it
        // destroy it if we can't connect
        // start a new one if it doesn't exist

        var viInfo = await StartVultrVm();

        // save the id, ip address, and label of the new instance
        SaveRemoteVmInfo(viInfo);

        // update DNS records so that the remote server can be found
        var dnsSplit = DnsHelper.SplitDnsName(broadcastServerDnsName);
        var dns = new UpdateCloudflareDNS(configuration["CloudFlareTokenKey"] ?? "");
        await dns.UpdateDnsAsync(dnsSplit.ZoneName, dnsSplit.RecordName, viInfo.PublicIPv4, new CancellationToken());


        // start ffmpeg stream to obs on local server
        // make sure obs is running on local server

        // connect to the obs websocket
        if (!obs.IsConnected)
            await ConnectToObs();

        //    https://gist.github.com/steinwaywhw/a4cd19cda655b8249d908261a62687f8

        // make sure obs scene selected is camera? Or...
        obs.SetCurrentProgramScene("Camera");

        // make sure obs is streaming
        if(!obs.GetRecordStatus().IsRecording)
            obs.StartRecord();

        // wait for remote server setup & 1st reboot to complete - poll & sleep
        int remoteCheckCount = 1;
        bool remoteReady = false;
        do
        {
            if (remoteCheckCount > 1)
                await Task.Delay(5000);
            alert_msg = $"Waiting for remote server to finish loading - check #: {remoteCheckCount}";
            Refresh();
            remoteReady = IsRemoteReady(viInfo.PublicIPv4);
            remoteCheckCount += 1;
        }
        while (remoteReady == false);

        SetupRemoteBroadcastServer(viInfo.PublicIPv4);

        // install ffmpeg
        // install docker (if needed)
        // setup rtmp broadcast service on remote server
        // setup user GUI on the remote server
        // configure services to start on boot on the remote server
        // start display of local stream on web page
        // start display of remote stream on web page
        alert_msg = "";
        Refresh();
        //var result = JS.InvokeAsync<object>("PlayVideo", "local_video", "/videos/elephants.mp4", 0);

        var result = JS.InvokeAsync<object>("PlayVideo", "local_video", "rtsp://172.17.17.45:8554/sac1", 0);

        SharedState.BCastState = SharedState.BroadcastState.running;

        //Refresh();
        await Task.Delay(0);
    }

    private async Task OnPause()
    {
        if (SharedState.BCastState == SharedState.BroadcastState.running)
        {
            // don't actuall pause the playback - just switch the video source to a static image
            //var result = JS.InvokeAsync<string>("PauseVideo", "local_video");
            SharedState.BCastState = SharedState.BroadcastState.paused;

            if (!obs.IsConnected)
                await ConnectToObs();

            if (obs.IsConnected)
            {
                obs.SetCurrentSceneCollection("Paused");
            }

        }
        //Refresh();
        await Task.Delay(0);
    }

    private async Task OnResume()
    {
        if (SharedState.BCastState == SharedState.BroadcastState.paused)
        {
            //var result = JS.InvokeAsync<object>("ResumeVideo", "local_video");
            SharedState.BCastState = SharedState.BroadcastState.running;

            if (!obs.IsConnected)
                await ConnectToObs();

            if (obs.IsConnected) 
            {
                obs.SetCurrentSceneCollection("Camera");
            }
        }
        Refresh();
        await Task.Delay(0);
    }

    private async Task OnStop()
    {
        SharedState.BCastState = SharedState.BroadcastState.stopped;
        //var result = JS.InvokeAsync<string>("PauseVideo", "local_video");
        alert_msg = string.Empty;
        Refresh();

        if (!obs.IsConnected)
            await ConnectToObs();

        if (obs.IsConnected) 
        {
            obs.SetCurrentSceneCollection("Paused");
            if (obs.GetRecordStatus().IsRecording)
                obs.StopRecord();
        }
        // destroy remote server
        // remove dns records

        await Task.Delay(0);
    }


    private async Task ConnectToObs()
    {
        try
        {
            if (!obs.IsConnected)
                await obs.ConnectAsync(obsUrl, obsKey);
        }
        catch (Exception ex)
        {
            alert_msg = "Connection to OBS service failed : " + ex.Message;
        }


        tcs = new TaskCompletionSource<bool>();
        var obs_connect = tcs.Task;
        int timeout = waitForObsConnection * 1000;
        if (!(await Task.WhenAny(obs_connect, Task.Delay(timeout)) == obs_connect))
        {
            // obs didn't start in time!
            alert_msg = "The OBS socket didn't connect in time!";
            return;
        }
    }

    private bool IsRemoteReady(string ipv4Address)
    {
        bool isReady = false;
        PrivateKeyFile keyFile = new PrivateKeyFile(sshPrivateFile);
        Renci.SshNet.PrivateKeyAuthenticationMethod auth = new PrivateKeyAuthenticationMethod(username: "root", keyFiles: keyFile);
        ConnectionInfo ci = new ConnectionInfo(host: ipv4Address, username: "root", authenticationMethods: auth);
        using (SshClient sshClient = new SshClient(ci))
        {

            SshCommand? cmdResult = null;
            if (!sshClient.IsConnected)
                try
                {
                    sshClient.Connect();
                }
                catch (Exception ex)
                {
                    alert_msg = "Failed to connect to the remote server"; 
                    Refresh();
                }

            if (sshClient.IsConnected)
            {
                cmdResult = sshClient.RunCommand("cat /started");
            }

            if (cmdResult is not null && cmdResult.ExitStatus == 0)
                isReady = true;

            if (sshClient.IsConnected)
                sshClient.Disconnect();

        }
        return isReady;
    }

    private void Refresh()
    {
        _ = InvokeAsync(() =>
        {
            StateHasChanged();
        });
    }


    private void SaveRemoteVmInfo(VultrInstanceInfo viInfo)
    {

        using (var connection = new SqliteConnection("Data Source=broadcast.db"))
        {
            connection.Open(); // will create the db file if it doesn't exist
            var command = connection.CreateCommand();

            command.CommandText = @"SELECT name 
FROM
  sqlite_schema
WHERE
  type ='table' 
  AND name = 'remote_vm'";

            if (command.ExecuteScalar() is null)
            {
                command.CommandText = "CREATE TABLE remote_vm (vm_id TEXT, vm_ip TEXT, vm_label TEXT);";
                command.ExecuteNonQuery();
            }

            command.CommandText =
                @"INSERT INTO remote_vm (vm_id, vm_ip, vm_label) SELECT $id, $ip, $label;";

            command.Parameters.AddWithValue("$id", viInfo.InstanceID);
            command.Parameters.AddWithValue("$ip", viInfo.PublicIPv4);
            command.Parameters.AddWithValue("$label", viInfo.InstanceLabel);
            command.ExecuteNonQuery();

            //using (var reader = command.ExecuteReader())
            //{
            //    while (reader.Read())
            //    {
            //        var name = reader.GetString(0);

            //        Console.WriteLine($"Hello, {name}!");
            //    }
            //}
        }
    }

    private void SetupRemoteBroadcastServer(string serverIP)
    {

        string rtspArchivePath = "/opt/rtsp-simple-server.tar.gz";
        string rtspConfPath = "/opt/rtsp-simple-server.yaml";

        PrivateKeyFile keyFile = new PrivateKeyFile(sshPrivateFile);
        Renci.SshNet.PrivateKeyAuthenticationMethod auth = new PrivateKeyAuthenticationMethod(username: "root", keyFiles: keyFile);
        ConnectionInfo ci = new ConnectionInfo(host: serverIP, username: "root", authenticationMethods: auth);
        using (ScpClient scpClient = new ScpClient(ci))
        using (StreamReader appReader = new StreamReader(rtspArchiveFullPath))
        //using (StreamReader confReader = new StreamReader(""))
        {
            scpClient.Connect();
            scpClient.Upload(source: appReader.BaseStream, path: rtspArchivePath);
            //scpClient.Upload(source: confReader.BaseStream, path: rtspConfPath);
            scpClient.Disconnect();
        }

        using (SshClient sshClient = new SshClient(ci))
        {
            sshClient.Connect();
            if (sshClient.IsConnected)
            {
                sshClient.RunCommand("apt install -y ffmpeg");
                sshClient.RunCommand($"cd /opt; tar -xaf {rtspArchivePath} ; mv {rtspConfPath} /opt/rtsp-simple-server ; ");
                sshClient.Disconnect();
            }
        }
    }

    private async Task<VultrInstanceInfo> StartVultrVm()
    {
        // need to read the public key data from the public key file.
        string sshPublicKey = File.ReadAllText(sshPublicFile);

        Vultr.API.VultrClient vc = new Vultr.API.VultrClient(apiKey: vultrKey, apiURL: vultrUrl);

        var sshList = vc.SSHKey.GetSSHKeys();
        var sshKey = sshList.SshKeys.Where(s => s.ssh_key == sshPublicKey).FirstOrDefault(new Ssh_Key());

        if (string.IsNullOrEmpty(sshKey.id))
            sshKey = vc.SSHKey.CreateSSHKey(name: "IF_North_BroadcastManager", ssh_key: sshPublicKey).SshKeys.FirstOrDefault();

        var regions = vc.Region.GetRegions();
        string[] excludedRegions = new[] { "atl", "ewr", "hnl", "mia", "ord", "lax" };
        var usRegions = regions.Regions.Where(r => r.country == "US" && !excludedRegions.Any(e => r.id.Contains(e))).ToList();

        var plans = vc.Plan.GetPlans(Vultr.Enums.PlanTypes.all);
        var sizedPlans = plans.Plans.Where(p => p.vcpu_count >= 2 && p.ram >= 4000 && p.type == PlanTypes.vhf.ToString()).ToList();

        var r2 = sizedPlans.FindAll(p => usRegions.Any(r => p.locations.Contains(r.id))).OrderBy(p => p.monthly_cost).ToArray();
        var plan1 = r2.FirstOrDefault(new Plan());
        var regionID = plan1.locations.Where(p => usRegions.Any(r => p.Contains(r.id))).FirstOrDefault("");

        var os_result = vc.OperatingSystem.GetOperatingSystems();
        var os = os_result.osList.Where(o => o.family == "ubuntu" && o.arch == "x64" && o.name.Contains("LTS")).ToList().OrderBy(o => o.name).ToList().LastOrDefault(new Os());

        var script = vc.StartupScript.GetStartupScripts().StartupScripts.Where(s => s.name == "test").FirstOrDefault(new Startup_Scripts());

        var sshkey = vc.SSHKey.GetSSHKeys();

        var instanceInfo = vc.Instance.CreateInstance(Label: "Broadcaster", Hostname: "broadcaster", RegionID: regionID, PlanID: plan1.id, SourceID: os.id.ToString(), Source: Vultr.Clients.InstanceClient.SourceType.os, ScriptID: script.id, SshKeyIDs: new[] { sshKey.id });

        VultrInstanceInfo viInfo = new VultrInstanceInfo() { InstanceID = instanceInfo.Instances[0].id };
        // give the provider a few seconds to allocate an IP address for the remote server
        int loopCount = 0;
        do
        {
            alert_msg = "Waiting for IP address allocation on the remote server";
            Refresh();
            loopCount += 1;
            await Task.Delay(2000);
            var instanceDetail = vc.Instance.GetInstance(viInfo.InstanceID);
            viInfo.PublicIPv4 = instanceDetail.Instances[0].main_ip;
            viInfo.InstanceLabel = instanceDetail.Instances[0].label;
        }
        while (viInfo.PublicIPv4 == "0.0.0.0" || loopCount >= 30);

        if (viInfo.PublicIPv4 is not null && viInfo.PublicIPv4 != "0.0.0.0")
            alert_msg = "Remote server IP address has been allocated.";
        else
            alert_msg = "Failed to get an IP address for the remote server before timing out.";
        Refresh();

        //var instanceList = vc.Instance.ListInstances();
        //var bcastInstance = instanceList.Instances.Where(o => o.label == "Broadcaster").FirstOrDefault(new Instance());

        //var instanceDelResult = vc.Instance.DeleteInstance(bcastInstance.id);
        return viInfo;
    }

    private struct VultrInstanceInfo
    {
        public string InstanceID { get; set; }

        [DefaultValue("0.0.0.0")]
        public string PublicIPv4 { get; set; }
        public string InstanceLabel { get; set; }
    }




}

