@page "/manager"
@using CliWrap;
@using Microsoft.AspNetCore.Authorization;
@using Microsoft.AspNetCore.Components.Authorization;
@using OBSWebsocketDotNet;
@using Renci.SshNet;
@using System.Diagnostics;

@inject IConfiguration configuration;
@inject IJSRuntime JS

@*@attribute [Authorize] *@

@inject NavigationManager NavManager;

<AuthorizeView>
    <Authorized>
        <p>Hello, @context.User?.Identity?.Name!</p>
        <p>obs_connected=@obs_connected.ToString()</p>
        <p><button @onclick="OnBtnStart" disabled="@(SharedState.BCastState != SharedState.BroadcastState.stopped)" name="Start">Start</button></p>
        <p><button @onclick="OnPause" disabled="@(SharedState.BCastState != SharedState.BroadcastState.running )" name="Pause">Pause</button></p>
        <p><button @onclick="OnResume" disabled="@(SharedState.BCastState != SharedState.BroadcastState.paused )" name="Resume">Resume</button></p>
        <p><button @onclick="OnStop" disabled="@(SharedState.BCastState == SharedState.BroadcastState.stopped || SharedState.BCastState == SharedState.BroadcastState.stopping )" name="Stop">Stop</button></p>
        @if (!String.IsNullOrWhiteSpace(alert_msg))
        {
            <p>@alert_msg</p>
        }
        <video id="local_video" defaultMuted="true" />
        <video id="remote_video">
            <source src="http://66.42.70.209:8000/live.ts", type="video/mp4"/>
        </video>
    </Authorized>
    <NotAuthorized>
        @{
            NavManager.NavigateTo("/");
        }
    </NotAuthorized>
</AuthorizeView>



@code {
    private OBSWebsocket obs = new OBSWebsocket();
    private string appDir = "";
    private string obsKey = "";
    private string obsUrl = "";
    private string sshPrivateFile = "";
    private string sshPublicFile = "";
    private string vultrKey = "";

    private bool obs_connected;
    private string alert_msg = "";

    protected override async Task OnInitializedAsync()
    {
        if (SharedState.BCastState is null)
            SharedState.BCastState = SharedState.BroadcastState.stopped;
        obs_connected = obs.IsConnected;
        obs.Connected += onObsConnect;

        appDir = Path.GetDirectoryName(Process.GetCurrentProcess().MainModule.FileName) ?? "";
        obsKey = configuration["ObsApiKey"] ?? "";
        obsUrl = configuration["ObsUrl"] ?? "";
        sshPrivateFile = configuration["SshPrivateKeyFile"] ?? "BroadcastManager_ssh_key";
        sshPublicFile = configuration["SshPublicKeyFile"] ?? "BroadcastManager_ssh_key.pub";
        vultrKey = configuration["VultrApiKey"] ?? "";

        if (!Path.IsPathRooted(sshPrivateFile))
            sshPrivateFile = Path.Combine(appDir, sshPrivateFile);

        if (!Path.IsPathRooted(sshPublicFile))
            sshPublicFile = Path.Combine(appDir, sshPublicFile);

        await Task.Delay(0);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender )
        {
        }
        await Task.Delay(0);
    }

    private void onObsConnect(object? sender, EventArgs e)
    {
        obs_connected = obs.IsConnected;
        Refresh();
    }

    private async Task OnBtnStart()
    {
        // don't even bother to lock if the app state is not stopped
        if (SharedState.BCastState is not null && SharedState.BCastState != SharedState.BroadcastState.stopped)
            return; // somebody else pressed the start button already. Don't need to repeat what they've started.

        lock (SharedState.LockObj)// don't want to hold a lock for the whole startup process - just make sure we are first, and then continue or exit.
        {
            if (SharedState.BCastState is not null && SharedState.BCastState != SharedState.BroadcastState.stopped)
                return; // somebody else pressed the start button already. Don't need to repeat what they've started.
            else
                SharedState.BCastState = SharedState.BroadcastState.starting;
        }

        // generate an ssh key pair if either doesn't exist
        if ( !File.Exists(sshPrivateFile) || !File.Exists(sshPublicFile) )
        {
            var sshResult = Cli.Wrap("ssh-keygen")
            .WithArguments($"-q -N '' -t ed25519 -C '{sshPrivateFile}' -f {Path.Combine(appDir, sshPrivateFile)}  <<<y >/dev/null 2>&1")
            .WithWorkingDirectory(appDir);
        }


        try
        {
            if(! obs.IsConnected )
                await obs.ConnectAsync(obsUrl, obsKey);
        }
        catch (Exception ex)
        {
            alert_msg = "Connection to OBS service failed : " + ex.Message;
        }

        // if the rtsp-simple-server archive isn't found, download it.
        //    https://gist.github.com/steinwaywhw/a4cd19cda655b8249d908261a62687f8
        // if obs isn't found on the local server, install it.
        // push basic obs config for live and pause scenes, recording out to rtsp-simple-server via ffmpeg multicast

        // start a new instance of the remote broadcast server
        // get IP address of new remote server
        // record ip and name somewhere... sqlite db?

        // start ffmpeg stream to obs on local server
        // make sure obs is running on local server
        // make sure obs scene selected is camera? Or...
        // make sure obs is streaming
        // make sure rtsp-simple-server is running on local server

        // wait for remote server setup & 1st reboot to complete
        // install ffmpeg
        // install docker (if needed)
        // setup rtmp broadcast service on remote server
        // setup user GUI on the remote server
        // configure services to start on boot on the remote server
        // start display of local stream on web page
        // start display of remote stream on web page

        Refresh();
        var result = JS.InvokeAsync<object>("PlayVideo", "local_video", "/videos/elephants.mp4", 0);

        SharedState.BCastState = SharedState.BroadcastState.running;
        
        //Refresh();
        await Task.Delay(0);
    }

    private async Task OnPause()
    {
        if (SharedState.BCastState == SharedState.BroadcastState.running)
        {
            // don't actuall pause the playback - just switch the video source to a static image
            var result = JS.InvokeAsync<string>("PauseVideo", "local_video");
            SharedState.BCastState = SharedState.BroadcastState.paused;
            await Task.Delay(0);
        }
        //Refresh();
        await Task.Delay(0);
    }

    private async Task OnResume()
    {
        if (SharedState.BCastState == SharedState.BroadcastState.paused)
        {
            var result = JS.InvokeAsync<object>("ResumeVideo", "local_video");
            SharedState.BCastState = SharedState.BroadcastState.running;
            // switch to sending static image & pre-recorded audio
        }
        Refresh();
        await Task.Delay(0);
    }

    private async Task OnStop()
    {
        // don't actually pause - shutdown source & stop & teardown icecast server
        SharedState.BCastState = SharedState.BroadcastState.stopped;
        var result = JS.InvokeAsync<string>("PauseVideo", "local_video");
        alert_msg = string.Empty;
        Refresh();
        await Task.Delay(0);
    }


    private void Refresh()
    {
        _ = InvokeAsync(() =>
        {
            StateHasChanged();
        });
    }


    private void SetupRemoteBroadcastServer(string serverIP)
    {

        string rtspArchivePath = "/opt/rtsp-simple-server.tar.gz";
        string rtspConfPath = "/opt/rtsp-simple-server.yaml";

        PrivateKeyFile keyFile = new PrivateKeyFile("");
        Renci.SshNet.PrivateKeyAuthenticationMethod auth = new PrivateKeyAuthenticationMethod(username: "root", keyFiles: keyFile);
        ConnectionInfo ci = new ConnectionInfo(host: serverIP, username: "root", authenticationMethods: auth);
        using (ScpClient scpClient = new ScpClient(ci))
        using (StreamReader appReader = new StreamReader(""))
        using (StreamReader confReader = new StreamReader(""))
        {
            scpClient.Connect();
            scpClient.Upload(source: appReader.BaseStream, path: rtspArchivePath);
            scpClient.Upload(source: confReader.BaseStream, path: rtspConfPath);
            scpClient.Disconnect();
        }

        using (SshClient sshClient = new SshClient(ci))
        {
            sshClient.Connect();
            if (sshClient.IsConnected)
            {
                sshClient.RunCommand("apt install -y ffmpeg");
                sshClient.RunCommand($"tar -xaf {rtspArchivePath} ; mv {rtspConfPath} /opt/rtsp-simple-server ; ");
                sshClient.Disconnect();
            }
        }
    }
}

